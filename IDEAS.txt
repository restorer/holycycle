# Идея

Проблема текущей либы, что она делает слишком мало полезного (с большего главный функционал этой либы можно просто "продублировать"
в проблемных местах, и это не будет требовать наследования от непонятных интерфейсов).

Надо бы сделать такую штуку, которая автомагически пофиксит проблемы жизненного цикла (ЖЦ) на всех версиях Android-а.
Например, унаследоваться от специальной активити, и всё станет сразу хорошо.
Или повесить магическую аннтотацию, которая что-то потом нагенерит, и тоже всё станет хорошо.

P.S. onActivityResult может вызываться до onStart, надо бы и это "пофиксить".

## Базовый класс

- Делаем ActivityProxy и ActivityDelegate.
- Пользовательскую активити наследуем от ActivityDelegate, и в манифесте не прописываем.
- ActivityProxy прописываем в манифесте, она будет внутри себя создавать пользовательскую активити.
- Прокси будет проксировать все public и protected вызовы в делегат (ну и наоборот, делегат если что запрашивает значения у прокси).
- И по умолчанию в делегате все эти методы не будут делать ничего (т.к. реальная работа будет в прокси).

Единственный плюс - нуууууу, возможно через какую-то такую вот жопу это и будет работать.

**Минусы:**

- public и protected методов очень дофигища.
- После выхода новой версии андроида, придётся либу патчить, иначе возможны большие проблемы.
- Есть final-методы, с которыми сходу не совладать (только если через рефлексию и с динамической генерацией байт-кода).
- Непонятно что делать, если пользовательскую активити нужно унаследовать от какой-то кастомной активити.
- Слишком много головняка пользователю либы, а профит не так очевиден.

## Аннотация

Или даже просто post-processing, который ищет активити в манифесте, находит нужный класс, генерит его наследника, который "фиксит" ЖЦ.

**Плюсы:**

- Достаточно просто выглядит.
- Не требует больших изменений в коде прилаги.
- Кажется, что либу не надо будет допиливать под каждую новую версию андроида, и всё и так будет хорошо работать.

**Проблемы:**

- В некоторых случаях вызов метода нужно не спускать к наследникам (например, "onStop()", т.к. он уже был вызван фиксом в "onSaveInstaceState()"). И, казалось бы, всё просто, но нет, т.к. получим "Activity ... did not call through to super.onStart()".
    - Но это можно решить через Reflection, хотя с таким подходом на какой-нибудь версии андроида всё может сломаться. Так же Reflection не поможет, если аналогичная проерка на "is called" есть в какой-нибудь либе.
- final-классы активитей, от которых нельзя наследоваться (усугубляется в котлине, т.к. там по умолчанию как раз final).
- Если создать класс с новым именем, это может сломать все "new Intent(this, ActivityClass.class)", не проходить же по коду и не менять всё.
    - Если сделать класс с таким же именем, то это возвращает нас к проблеме "final-классов", когда требуется модификация уже написанного кода

Но пасаны пишут, что в принципе это возможно либо путём использования хаков в компиляторе, либо путём модификации байткода - http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html
А т.к. гугл отказался от Jack, то, наверное, модификация байткода может покатить (кстааааати, а ведь прогард как раз по байткоду проходится).

## Post-processing байт-кода

Выглядит наиболее многообещающе. Идея такая, что на каком-то этапе сборки (желательно перед прогардом, или там новым R8) внедряемся, и производим такие манипуляции над активитями, которые нам удалось найти в манифесте (достаточно только над ними, никакие базовые классы трогать не придётся):

- Все нужные нам методы ("onResume()", "onPause()", "onStop()", "onSaveInstanceState()") переименовываем в "__hc_this_...", например "__hc__this_onStop()", метод может быть приватным, во избежание.
- Может быть (а может и нет) все super-вызовы этих же методов заменяем на "__hc_super_...", например, "super.onStop()" заменяем на "__hc__super_onStop()".
- Это всё даст либе полный (или почти полный) контроль над происходящим.
- Создаём настоящие методы. Например, без замены super-ов метод "onStop()" может быть таким:

protected void onStop() {
    if (hostState == HOST_DESTROYED || hostState == HOST_INSTANCE_STATE_SAVED) {
        // Вызываем super.onStop() вручную, чтобы избежать "didn't call through to super.onStop()".
        // **Тут есть проблема, см. ниже.**
        super.onStop();
        return;
    }

    hostState = HOST_CREATED;
    __hc_this_onStop(); // super.onStop() будет вызван внутри метода, так что должно быть ок
}

**Проблемы:**

- Мы можем "пропустить" onStop() в этом конкретном классе, но нам всё равно придётся вызывть его в родительском, что может привести к проблемам.
    - Либо пост-процессить вообще все наследники от Activity, либо использовать Reflection и устанавнивать "mCalled = true". Но это может не помочь в тех случаях, когда пользовательская activity наследуется от какой-то либы, и внутри либы тоже есть проверка на "is called".
    - Пост-процессинг вообще всего - более правильно, но сложно. Reflection лучше подойдёт для PoC.
- Возможно, какой-нибудь какашечный код будет внутри себя вызывать "onStop()", причём это может быть как конкретно в этом классе, так и в каком-нибудь родительском.
    - И тут может быть и хорошо, что реальный "onStop" не будет вызван, и плохо (например, в прилаге какая-то хитрая логика, что можно вызывать "наш" onStop, и он что-то сделает, и ещё и не вызовет родительский). It depends.
    - Но скорее это хорошо, т.к. такой хитрокод нужно фиксить.

Ещё размышления над тем, над какими активитями проводить манипуляции:

- Если брать все из манифеста, то есть риск "пропатчить" то, что патчить не нужно.
- Если только те, над которыми висит аннотация, то можно заколебаться её ставить.
- Лучше процессить те, над которыми аннотация, наследников тех, над которой аннотация, и ещё может отдельно в конфиге каком-нибудь задавать.
    - Даже собственно так - процессить нужно только те, которые прописаны в манифесте. Т.е. сначала строится некий dependency graph, потом по нему смотрится что из этого есть в манифесте, и потом только нужные классы патчатся.

Во. Вроде так может срастись.

## Post-processing v2

Так же как и в предыдущем случае, патчим байт-код. Но вызываем super-метод напрямую через INVOKESPECIAL:

ALOAD X ; X = slot of object reference of the object to access
INVOKESPECIAL java/lang/Object.toString ()Ljava/lang/String;
POP

https://stackoverflow.com/a/38925713
https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokespecial

И ещё вместо переименовывания методов, можно переименовать класс, а в байт-коде сгенерировать класс с изначальным именем, и в нём делать всю обработку, и через INVOKESPECIAL либо через super.xxx() контроллировать что и как вызывается.

Проблем от того, что будет инстанциироваться класс-заглушка, а не изначальный класс быть не должно, т.к. a) ну в общем-то этого то я и добиваюсь; b) активити не должны создаваться вручную; c) а даже если и так, что ничего страшного, только если вызывающий код в такой вручную созданной активити будет вызывать методы жизненного цикла, то будет авто-патч, даже если он и не нужен вдруг.

## Post-processing v3

Но есть ещё проблемка - например, иногда нужно не просто "пропустить" вызов метода (но вызвать его у Activity, ибо mCalled), но наоборот, вызвать метод в неподходящее время, например, пришёл onSaveInstanceState до onStop, и нужно вызвать onStop вручную. Вероятно, всё будет хорошо.

Но вот в случае onActivityResult наверное нельзя вот просто так взять и вызвать onStart, если он ещё не вызывался ранее. Вместо этого нужно "попридержать" результат, и уже после обработки onStart вызвать onActivityResult. Тогда получится, что Activity.onActivityResult будет вызван 2 раза - первый раз, когда функция "скипается" для того чтобы попридержать результат, и второй раз, когда она реально вызывается.

Ладно, в случае onActivityResult глобальной проблемы нет, т.к. в Activity тело метода пустое, т.е. можно вообще не вызывать Activity.onActivityResult(). Но чисто теоретически, можно попробовать подойти другим образом. Например, есть такая цепочка активитей, от конечной до android.app.Activity:

SomeActivity <- BaseToolbarActivity <- BaseActivity <- CoreMviActivity <- CoreActivity <- AppCompatActivity <- FragmentActivity <- androidx.activity.ComponentActivity <- androidx.core.app.ComponentActivity <- Activity

Делаем из неё такую цепочку:

SomeActivity <- __HC_SomeActivity <- BaseToolbarActivity <- BaseActivity <- CoreMviActivity <- CoreActivity <- AppCompatActivity <- FragmentActivity <- androidx.activity.ComponentActivity <- androidx.core.app.ComponentActivity <- __HC_Activity <- Activity

Т.е. a) Все конечные активити переименовываем в __HC_..., а вместо них с такими же именами создаём класс-фиксер; b) Делаем класс-заменитель __HC_Activity, и патчим весь байткод таким образом, что всё что наследовалось от Activity теперь наследуется от __HC_Activity (включая все либы, и даже AndroidX / support).

Таким образом можно полностью контроллировать что и как вызывается.
