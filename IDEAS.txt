# Идея

Проблема текущей либы, что она делает слишком мало полезного (с большего главный функционал этой либы можно просто "продублировать"
в проблемных местах, и это не будет требовать наследования от непонятных интерфейсов).

Надо бы сделать такую штуку, которая автомагически пофиксит проблемы жизненного цикла (ЖЦ) на всех версиях Android-а.
Например, унаследоваться от специальной активити, и всё станет сразу хорошо.
Или повесить магическую аннтотацию, которая что-то потом нагенерит, и тоже всё станет хорошо.

## Базовый класс

- Делаем ActivityProxy и ActivityDelegate.
- Пользовательскую активити наследуем от ActivityDelegate, и в манифесте не прописываем.
- ActivityProxy прописываем в манифесте, она будет внутри себя создавать пользовательскую активити.
- Прокси будет проксировать все public и protected вызовы в делегат (ну и наоборот, делегат если что запрашивает значения у прокси).
- И по умолчанию в делегате все эти методы не будут делать ничего (т.к. реальная работа будет в прокси).

Единственный плюс - нуууууу, возможно через какую-то такую вот жопу это и будет работать.

**Минусы:**

- public и protected методов очень дофигища.
- После выхода новой версии андроида, придётся либу патчить, иначе возможны большие проблемы.
- Есть final-методы, с которыми сходу не совладать (только если через рефлексию и с динамической генерацией байт-кода).
- Слишком много головняка пользователю либы, а профит не так очевиден.

## Аннотация

Или даже просто post-processing, который ищет активити в манифесте, находит нужный класс, генерит его наследника, который "фиксит" ЖЦ.

**Плюсы:**

- Достаточно просто выглядит.
- Не требует больших изменений в коде прилаги.
- Кажется, что либу не надо будет допиливать под каждую новую версию андроида, и всё и так будет хорошо работать.

**Проблемы:**

- В некоторых случаях вызов метода нужно не спускать к наследникам (например, "onStop()", т.к. он уже был вызван фиксом в "onSaveInstaceState()"). И, казалось бы, всё просто, но нет, т.к. получим "Activity ... did not call through to super.onStart()".
    - Но это можно решить через Reflection, хотя с таким подходом на какой-нибудь версии андроида всё может сломаться.
- final-классы активитей, от которых нельзя наследоваться (усугубляется в котлине, т.к. там по умолчанию как раз final).
- Если создать класс с новым именем, это может сломать все "new Intent(this, ActivityClass.class)", не проходить же по коду и не менять всё.
    - Если сделать класс с таким же именем, то это возвращает нас к проблеме "final-классов", когда требуется модификация уже написанного кода

Но пасаны пишут, что в принципе это возможно либо путём использования хаков в компиляторе, либо путём модификации байткода - http://notatube.blogspot.com/2010/11/project-lombok-trick-explained.html
А т.к. гугл отказался от Jack, то, наверное, модификация байткода может покатить (кстааааати, а ведь прогард как раз по байткоду проходится).

## Post-processing байт-кода

Выглядит наиболее многообещающе. Идея такая, что на каком-то этапе сборки (желательно перед прогардом, или там новым R8) внедряемся, и производим такие манипуляции над активитями, которые нам удалось найти в манифесте (достаточно только над ними, никакие базовые классы трогать не придётся):

- Все нужные нам методы ("onResume()", "onPause()", "onStop()", "onSaveInstanceState()") переименовываем в "__hc_this_...", например "__hc__this_onStop()", метод может быть приватным, во избежание.
- Может быть (а может и нет) все super-вызовы этих же методов заменяем на "__hc_super_...", например, "super.onStop()" заменяем на "__hc__super_onStop()".
- Это всё даст либе полный (или почти полный) контроль над происходящим.
- Создаём настоящие методы. Например, без замены super-ов метод "onStop()" может быть таким:

protected void onStop() {
    if (hostState == HOST_DESTROYED || hostState == HOST_INSTANCE_STATE_SAVED) {
        // Вызываем super.onStop() вручную, чтобы избежать "didn't call through to super.onStop()".
        // **Тут есть проблема, см. ниже.**
        super.onStop();
        return;
    }

    hostState = HOST_CREATED;
    __hc_this_onStop(); // super.onStop() будет вызван внутри метода, так что должно быть ок
}

**Проблемы:**

- Мы можем "пропустить" onStop() в этом конкретном классе, но нам всё равно придётся вызывть его в родительском, что может привести к проблемам.
    - Либо пост-процессить вообще все наследники от Activity, либо использовать Reflection и устанавнивать "mCalled = true".
    - Пост-процессинг вообще всего - более правильно, но сложно. Reflection лучше подойдёт для PoC.
- Возможно, какой-нибудь какашечный код будет внутри себя вызывать "onStop()", причём это может быть как конкретно в этом классе, так и в каком-нибудь родительском.
    - И тут может быть и хорошо, что реальный "onStop" не будет вызван, и плохо (например, в прилаге какая-то хитрая логика, что можно вызывать "наш" onStop, и он что-то сделает, и ещё и не вызовет родительский). It depends.
    - Но скорее это хорошо, т.к. такой хитрокод нужно фиксить.

Ещё размышления над тем, над какими активитями проводить манипуляции:

- Если брать все из манифеста, то есть риск "пропатчить" то, что патчить не нужно.
- Если только те, над которыми висит аннотация, то можно заколебаться её ставить.
- Лучше процессить те, над которыми аннотация, наследников тех, над которой аннотация, и ещё может отдельно в конфиге каком-нибудь задавать.
    - Даже собственно так - процессить нужно только те, которые прописаны в манифесте. Т.е. сначала строится некий dependency graph, потом по нему смотрится что из этого есть в манифесте, и потом только нужные классы патчатся.

Во. Вроде так может срастись.
